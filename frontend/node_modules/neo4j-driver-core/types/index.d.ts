/**
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { newError, Neo4jError, newGQLError, GQLError, isRetryableError, isRetriableError } from './error';
import Integer, { int, isInt, inSafeRange, toNumber, toString } from './integer';
import { Date, DateTime, Duration, isDate, isDateTime, isDuration, isLocalDateTime, isLocalTime, isTime, LocalDateTime, LocalTime, Time } from './temporal-types';
import { StandardDate, NumberOrInteger, Node, isNode, Relationship, isRelationship, UnboundRelationship, isUnboundRelationship, Path, isPath, PathSegment, isPathSegment } from './graph-types';
import Record, { RecordShape } from './record';
import { isPoint, Point } from './spatial-types';
import ResultSummary, { queryType, ServerInfo, Plan, ProfiledPlan, QueryStatistics, Stats } from './result-summary';
import GqlStatusObject, { NotificationPosition, NotificationSeverityLevel, NotificationClassification, NotificationCategory, Notification, notificationCategory, notificationClassification, notificationSeverityLevel } from './notification';
import NotificationFilter, { notificationFilterDisabledCategory, NotificationFilterDisabledCategory, notificationFilterDisabledClassification, NotificationFilterDisabledClassification, notificationFilterMinimumSeverityLevel, NotificationFilterMinimumSeverityLevel } from './notification-filter';
import Result, { MappedQueryResult, QueryResult, ResultObserver } from './result';
import EagerResult from './result-eager';
import ConnectionProvider, { Releasable } from './connection-provider';
import Connection from './connection';
import Transaction from './transaction';
import ManagedTransaction from './transaction-managed';
import TransactionPromise from './transaction-promise';
import Session, { TransactionConfig } from './session';
import Driver, * as driver from './driver';
import auth from './auth';
import BookmarkManager, { BookmarkManagerConfig, bookmarkManager } from './bookmark-manager';
import AuthTokenManager, { authTokenManagers, AuthTokenManagers, staticAuthTokenManager, AuthTokenAndExpiration } from './auth-token-manager';
import { SessionConfig, QueryConfig, RoutingControl, routing } from './driver';
import { Config } from './types';
import * as types from './types';
import * as json from './json';
import resultTransformers, { ResultTransformer } from './result-transformers';
import ClientCertificate, { clientCertificateProviders, ClientCertificateProvider, ClientCertificateProviders, RotatingClientCertificateProvider, resolveCertificateProvider } from './client-certificate';
import * as internal from './internal';
import { ProtocolVersion } from './internal/protocol-version';
import Vector, { VectorType, vector, isVector } from './vector';
import { StandardCase } from './mapping.nameconventions';
import { Rule, Rules, RecordObjectMapping } from './mapping.highlevel';
import { rule } from './mapping.rulesfactories';
import mappingDecorators from './mapping.decorators';
import UnsupportedType, { isUnsupportedType } from './unsupported-type';
/**
 * Object containing string constants representing predefined {@link Neo4jError} codes.
 */
declare const error: {
    SERVICE_UNAVAILABLE: string;
    SESSION_EXPIRED: string;
    PROTOCOL_ERROR: string;
};
/**
 * @private
 */
declare const forExport: {
    authTokenManagers: AuthTokenManagers;
    newError: typeof newError;
    Neo4jError: typeof Neo4jError;
    newGQLError: typeof newGQLError;
    GQLError: typeof GQLError;
    isRetryableError: typeof Neo4jError.isRetryable;
    isRetriableError: typeof Neo4jError.isRetriable;
    error: {
        SERVICE_UNAVAILABLE: string;
        SESSION_EXPIRED: string;
        PROTOCOL_ERROR: string;
    };
    Integer: typeof Integer;
    int: typeof Integer.fromValue;
    isInt: typeof Integer.isInteger;
    inSafeRange: typeof Integer.inSafeRange;
    toNumber: typeof Integer.toNumber;
    toString: typeof Integer.toString;
    internal: typeof internal;
    isPoint: typeof isPoint;
    Point: typeof Point;
    Date: typeof Date;
    DateTime: typeof DateTime;
    Duration: typeof Duration;
    isDate: typeof isDate;
    isDateTime: typeof isDateTime;
    isDuration: typeof isDuration;
    isLocalDateTime: typeof isLocalDateTime;
    isLocalTime: typeof isLocalTime;
    isTime: typeof isTime;
    LocalDateTime: typeof LocalDateTime;
    LocalTime: typeof LocalTime;
    Time: typeof Time;
    Node: typeof Node;
    isNode: typeof isNode;
    Relationship: typeof Relationship;
    isRelationship: typeof isRelationship;
    UnboundRelationship: typeof UnboundRelationship;
    isUnboundRelationship: typeof isUnboundRelationship;
    Path: typeof Path;
    isPath: typeof isPath;
    PathSegment: typeof PathSegment;
    isPathSegment: typeof isPathSegment;
    Record: typeof Record;
    ResultSummary: typeof ResultSummary;
    queryType: {
        READ_ONLY: string;
        READ_WRITE: string;
        WRITE_ONLY: string;
        SCHEMA_WRITE: string;
    };
    ServerInfo: typeof ServerInfo;
    Notification: typeof Notification;
    GqlStatusObject: typeof GqlStatusObject;
    Plan: typeof Plan;
    ProfiledPlan: typeof ProfiledPlan;
    QueryStatistics: typeof QueryStatistics;
    Stats: typeof Stats;
    Result: typeof Result;
    EagerResult: typeof EagerResult;
    Transaction: typeof Transaction;
    ManagedTransaction: typeof ManagedTransaction;
    TransactionPromise: typeof TransactionPromise;
    Session: typeof Session;
    Driver: typeof Driver;
    Connection: typeof Connection;
    Releasable: typeof Releasable;
    types: typeof types;
    driver: typeof driver;
    json: typeof json;
    auth: {
        basic: (username: string, password: string, realm?: string) => {
            scheme: string;
            principal: string;
            credentials: string;
            realm: string;
        } | {
            scheme: string;
            principal: string;
            credentials: string;
            realm?: undefined;
        };
        kerberos: (base64EncodedTicket: string) => {
            scheme: string;
            principal: string;
            credentials: string;
        };
        bearer: (base64EncodedToken: string) => {
            scheme: string;
            credentials: string;
        };
        none: () => {
            scheme: string;
        };
        custom: (principal: string, credentials: string, realm: string, scheme: string, parameters?: object) => any;
    };
    bookmarkManager: typeof bookmarkManager;
    routing: {
        WRITE: "WRITE";
        READ: "READ";
    };
    resultTransformers: {
        eagerResultTransformer<Entries extends RecordShape = RecordShape>(): ResultTransformer<EagerResult<Entries>>;
        eager<Entries extends RecordShape = RecordShape>(): ResultTransformer<EagerResult<Entries>>;
        mappedResultTransformer<R = Record<RecordShape<PropertyKey, any>, PropertyKey, RecordShape<PropertyKey, number>>, T = {
            records: R[];
            keys: string[];
            summary: ResultSummary;
        }>(config: {
            map?: (rec: Record) => R | undefined;
            collect?: (records: R[], summary: ResultSummary, keys: string[]) => T;
        }): ResultTransformer<T>;
        mapped<R = Record<RecordShape<PropertyKey, any>, PropertyKey, RecordShape<PropertyKey, number>>, T = {
            records: R[];
            keys: string[];
            summary: ResultSummary;
        }>(config: {
            map?: (rec: Record) => R | undefined;
            collect?: (records: R[], summary: ResultSummary, keys: string[]) => T;
        }): ResultTransformer<T>;
        first<Entries extends RecordShape = RecordShape>(): ResultTransformer<Record<Entries> | undefined>;
        summary<T extends NumberOrInteger = Integer>(): ResultTransformer<ResultSummary<T>>;
        hydrated<T extends {} = Object>(rules: Rules): ResultTransformer<{
            records: T[];
            summary: ResultSummary;
        }>;
        hydrated<T extends {} = Object>(genericConstructor: import("./mapping.highlevel").GenericConstructor<T>, rules?: Rules): ResultTransformer<{
            records: T[];
            summary: ResultSummary;
        }>;
    };
    notificationCategory: {
        UNKNOWN: "UNKNOWN";
        HINT: "HINT";
        UNRECOGNIZED: "UNRECOGNIZED";
        UNSUPPORTED: "UNSUPPORTED";
        PERFORMANCE: "PERFORMANCE";
        TOPOLOGY: "TOPOLOGY";
        SECURITY: "SECURITY";
        DEPRECATION: "DEPRECATION";
        GENERIC: "GENERIC";
        SCHEMA: "SCHEMA";
    };
    notificationClassification: {
        UNKNOWN: "UNKNOWN";
        HINT: "HINT";
        UNRECOGNIZED: "UNRECOGNIZED";
        UNSUPPORTED: "UNSUPPORTED";
        PERFORMANCE: "PERFORMANCE";
        TOPOLOGY: "TOPOLOGY";
        SECURITY: "SECURITY";
        DEPRECATION: "DEPRECATION";
        GENERIC: "GENERIC";
        SCHEMA: "SCHEMA";
    };
    notificationSeverityLevel: {
        UNKNOWN: "UNKNOWN";
        WARNING: "WARNING";
        INFORMATION: "INFORMATION";
    };
    notificationFilterDisabledCategory: {
        HINT: "HINT";
        UNRECOGNIZED: "UNRECOGNIZED";
        UNSUPPORTED: "UNSUPPORTED";
        PERFORMANCE: "PERFORMANCE";
        TOPOLOGY: "TOPOLOGY";
        SECURITY: "SECURITY";
        DEPRECATION: "DEPRECATION";
        GENERIC: "GENERIC";
        SCHEMA: "SCHEMA";
    };
    notificationFilterDisabledClassification: {
        HINT: "HINT";
        UNRECOGNIZED: "UNRECOGNIZED";
        UNSUPPORTED: "UNSUPPORTED";
        PERFORMANCE: "PERFORMANCE";
        TOPOLOGY: "TOPOLOGY";
        SECURITY: "SECURITY";
        DEPRECATION: "DEPRECATION";
        GENERIC: "GENERIC";
        SCHEMA: "SCHEMA";
    };
    notificationFilterMinimumSeverityLevel: {
        WARNING: "WARNING";
        INFORMATION: "INFORMATION";
        OFF: "OFF";
    };
    clientCertificateProviders: ClientCertificateProviders;
    resolveCertificateProvider: typeof resolveCertificateProvider;
    ProtocolVersion: typeof ProtocolVersion;
    rule: Readonly<{
        asBoolean(rule?: Rule): Rule;
        asString(rule?: Rule): Rule;
        asNumber(rule?: Rule & {
            acceptBigInt?: boolean;
        }): Rule;
        asBigInt(rule?: Rule & {
            acceptNumber?: boolean;
        }): Rule;
        asNode(rule?: Rule): Rule;
        asRelationship(rule?: Rule): Rule;
        asUnboundRelationship(rule?: Rule): Rule;
        asPath(rule?: Rule): Rule;
        asPoint(rule?: Rule): Rule;
        asDuration(rule?: Rule & {
            stringify?: boolean;
        }): Rule;
        asLocalTime(rule?: Rule & {
            stringify?: boolean;
        }): Rule;
        asTime(rule?: Rule & {
            stringify?: boolean;
        }): Rule;
        asDate(rule?: Rule & {
            stringify?: boolean;
            toStandardDate?: boolean;
        }): Rule;
        asLocalDateTime(rule?: Rule & {
            stringify?: boolean;
            toStandardDate?: boolean;
        }): Rule;
        asDateTime(rule?: Rule & {
            stringify?: boolean;
            toStandardDate?: boolean;
        }): Rule;
        asList(rule?: Rule & {
            apply?: Rule;
        }): Rule;
        asVector(rule?: Rule & {
            asTypedList?: boolean;
        }): Rule;
    }>;
    mappingDecorators: {
        booleanProperty: (config?: Rule) => (_: any, context: any) => void;
        stringProperty: (config?: Rule) => (_: any, context: any) => void;
        numberProperty: (config?: Rule & {
            acceptBigInt?: boolean;
        }) => (_: any, context: any) => void;
        bigIntProperty: (config?: Rule & {
            acceptNumber?: boolean;
        }) => (_: any, context: any) => void;
        nodeProperty: (config?: Rule) => (_: any, context: any) => void;
        relationshipProperty: (config?: Rule) => (_: any, context: any) => void;
        pathProperty: (config?: Rule) => (_: any, context: any) => void;
        pointProperty: (config?: Rule) => (_: any, context: any) => void;
        durationProperty: (config?: Rule & {
            stringify?: boolean;
        }) => (
        /**
         * @private
         */
        _: any, context: any) => void;
        listProperty: (config?: Rule & {
            apply?: Rule;
        }) => (_: any, context: any) => void;
        vectorProperty: (config?: Rule & {
            asTypedList?: boolean;
        }) => (_: any, context: any) => void;
        optionalProperty: () => (_: any, context: any) => void;
        mapPropertyFromName: (name: string) => (_: any, context: any) => void;
        convertPropertyToType: (type: any) => (_: any, context: any) => void;
        mappedClass: () => (_: any, context: any) => void;
    };
    RecordObjectMapping: Readonly<{
        clearMappingRegistry: () => void;
        getCaseTranslator: (databaseConvention: string, codeConvention: string) => ((name: string) => string);
        register: <T extends {} = Object>(constructor: import("./mapping.highlevel").GenericConstructor<T>, rules: Rules) => void;
        translateIdentifiers: (translationFunction: (name: string) => string) => void;
    }>;
    StandardCase: typeof StandardCase;
    UnsupportedType: typeof UnsupportedType;
    isUnsupportedType: typeof isUnsupportedType;
    isVector: typeof isVector;
    vector: typeof vector;
};
export { authTokenManagers, newError, Neo4jError, newGQLError, GQLError, isRetryableError, isRetriableError, error, Integer, int, isInt, inSafeRange, toNumber, toString, internal, isPoint, Point, Date, DateTime, Duration, isDate, isDateTime, isDuration, isLocalDateTime, isLocalTime, isTime, LocalDateTime, LocalTime, Time, Node, isNode, Relationship, isRelationship, UnboundRelationship, isUnboundRelationship, Path, isPath, PathSegment, isPathSegment, Record, ResultSummary, queryType, ServerInfo, Notification, GqlStatusObject, Plan, ProfiledPlan, QueryStatistics, Stats, Result, EagerResult, ConnectionProvider, Releasable, Connection, Transaction, ManagedTransaction, TransactionPromise, Session, Driver, types, driver, json, auth, bookmarkManager, staticAuthTokenManager, routing, resultTransformers, notificationCategory, notificationClassification, notificationSeverityLevel, notificationFilterDisabledCategory, notificationFilterDisabledClassification, notificationFilterMinimumSeverityLevel, clientCertificateProviders, resolveCertificateProvider, isVector, Vector, vector, ProtocolVersion, rule, mappingDecorators, RecordObjectMapping, StandardCase, UnsupportedType, isUnsupportedType, };
export type { StandardDate, NumberOrInteger, NotificationPosition, QueryResult, MappedQueryResult, ResultObserver, TransactionConfig, BookmarkManager, BookmarkManagerConfig, AuthTokenManager, AuthTokenManagers, AuthTokenAndExpiration, Config, SessionConfig, QueryConfig, RoutingControl, RecordShape, ResultTransformer, NotificationCategory, NotificationClassification, NotificationSeverityLevel, NotificationFilter, NotificationFilterDisabledCategory, NotificationFilterDisabledClassification, NotificationFilterMinimumSeverityLevel, ClientCertificate, ClientCertificateProvider, ClientCertificateProviders, RotatingClientCertificateProvider, VectorType, Rule, Rules };
export default forExport;
